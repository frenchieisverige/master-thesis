% ----------------------------------------------------------------------------------------
% Name: Related Work and Basic Principles
% Author: Emmanuel SCHWARTZ
% Date: November 2016
% Description: Related Work and Basic Principles Chapter for my master thesis paper
% ----------------------------------------------------------------------------------------
\section{Related Work}


\subsection{Towards Cloud-Based Decentralized Storage for IoT}
\subsection{Prototype of cloud based document management for scientific work validation}
\subsection{Sia}

\section{Basic Principles}

\subsection{Reminders in Cryptography: Hash, Signature and Merkle tree}
\subsubsection{Hash Function}
\paragraph{}
A hash function is an algorithm that generates a numeric, or fixed-size character output from a variable-sized piece of text or other data (Figure 2.1). An essential property is that it is practically impossible to reverse it: the hash of a datum by the function is calculated very efficiently, but the inverse calculation of an input hash to find a datum is infeasible. For this reason, such a function is said to be one-way.The input data is often called the message, and the output (the hash value or hash) is often called the message digest or simply the digest.

\paragraph{}
{\setlength{\parindent}{0cm}
An ideal cryptographic hash function has the following four properties:
}

\begin{itemize}
  \setlength\itemsep{0em}

  \item Collision resistant: It is hard to find for a given \emph{m1} any \emph{m2} with \emph{H(m1) = H(m2)}. Two messages can't have the same footprint.
  \item Non-reversible: It is hard to find \emph{m} given \emph{H(m)}. It is impossible for a given hash value to construct a message having that hash value except by trying all possible messages.
  \item Fast: The hash value of a message is calculated very quickly
  \item Unique: A small change to a message should change the hash value so extensively that the new hash value appears uncorrelated with the old hash value.

\end{itemize}

\paragraph{}
The most common hash functions are listed below:
\begin{itemize}
  \setlength\itemsep{0em}

  \item MD4 and MD5 (Message Digest) were developed by Ron Rivest. MD5 produces 128-bit hashes by working the original data in blocks of 512 bits.
  \item SHA-1 (Secure Hash Algorithm 1), like MD5, is based on MD4. It also operates from blocks of 512 bits of data and produces condensed bits of 160 bits at the output. It therefore requires more resources than MD5.[*]
   \item SHA-2 (Secure Hash Algorithm 2) has been published recently and is intended to replace SHA-1. The main differences are in the possible chopping sizes: 256, 384, or 512 bits. It will soon be the new reference in terms of hash function.[*]
  \item RIPEMD-160 (Ripe Message Digest) is the latest version of the RIPEMD algorithm. The previous version produced 128-bit digits but presented significant security flaws. The current version remains safe for now; It produces as the name indicates the condensed 160 bits. A final point concerning it is its relative greediness in terms of resources and in comparison with SHA-1 which is its main rival.
\end{itemize}

\paragraph{}
\begin{figure}[!h]
\begin{center}
\resizebox{\columnwidth}{!}{%
\begin{tabular}{|c|c|}
\hline
	text & hash(text)\\
\hline
	Here is a long text & faf3d315060c6b887e826e7a65992539e846233cea3f2e4cde4d9351b4f00193\\
\hline
	Hello World! & 7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069\\
\hline
	Hello World. & f4bb1975bf1f81f76ce824f7536c1e101a8060a632a52289d530a6f600d52c92\\
\hline
	Hello World. & f4bb1975bf1f81f76ce824f7536c1e101a8060a632a52289d530a6f600d52c92\\
\hline
\end{tabular}%
}
\caption{Example of an hash function}
\end{center}
\end{figure}

\subsubsection{Signature}

The digital signature[*] is a mechanism to guarantee the integrity of an electronic document and to authenticate the author by analogy with the handwritten signature of a paper document. It must allow the reader of a document to identify the person or organization that has affixed his/her signature. Moreover, a digital signature mechanism must have the following properties:

\begin{itemize}
  \setlength\itemsep{0em}

  \item Authentic: the identity of the signatory must be able to be found with certainty
  \item Forgery: the signature can not be falsified. Someone can not pretend to be another
  \item Not reusable: the signature is not reusable. It is part of the signed document and can not be moved to another document.
  \item Unalterable: A signed document is unalterable. Once it is signed, you can not change it
  \item Irrevocable: the person who signed can not deny it

\end{itemize}

In order to sign a document, the common way to do it is to use keys. Each user has a pairs of keys: a public one, called PubKey, and a private key, nammed PrivKey.
\begin{figure}[htp]
\centering
\includegraphics[scale=0.30]{/home/emmanuel/Documents/masterThesis/doc/ressources/signature.png}
\caption{Digital signature}
\label{}
\end{figure}

\subsubsection{Merkle Tree}
\paragraph{}
Created in 1979 by Ralf Merkle, one of the pionner of the asymetrical cryptography, the Merkle tree, or hash tree, is data structure containing an information summary of a data volume, which are usually big. (see figure X.X).
\begin{figure}[!h]
\centering
\includegraphics[scale=0.50]{/home/emmanuel/Documents/masterThesis/doc/ressources/merkle.png}
\caption{Merkel tree}
\label{}
\end{figure}
\paragraph{}
The principle of a hash tree consists of decomposing the input data into a set of blocks of identical size. These blocks are the leaves of the tree. They are usually completed with neutral values, such as zeros, so as to obtain blocks of the desired size. The higher level nodes are then obtained by compressing the nodes of the current level using a hash / compression function until only one node is obtained: the Merkle root hash.
With this principle, the hash tree gives a unique footprint of all data. By just storing the root hash, it is very easy to large data comparaison by anylysing only the Merkle root hashes without the need to download these large data files. Moreover, it also can detect if a data has been modified. 
\paragraph{}
The field of applications of the Merkle tree are wide-spreaded going from Peer-2-Peer[*] networks to GIT[*] or even ZFS file system[*]

\subsection{Blockchains}
\paragraph{}
This section will explain blockchains and its components in a global scope through the famous cryptocurrency: Bitcoin.

\subsubsection{What is a blockchain?}
\paragraph{}
Bitcoin brought with him a new concept: The system operates without central authority or single administrator, but in a decentralized way thanks to the consensus of all the nodes of the network, this means everynode have to reach an agreement in order to go to the next step. 
\paragraph{}
A blockchain is a public ledger of all transactions that have ever been executed. Based on a distributed database, it maintains a continuously-growing list of a ‘completed’ blocks are added to it with a new set of recordings. As its name suggests, the blockchain is a succession of blocks. The blocks are added to the blockchain in a linear and chronological order. Each blocks are linked by incorporating the hash of the previous block, showed in Figure 2.3:
\begin{figure}[htp]
\centering
\includegraphics[scale=0.42]{/home/emmanuel/Documents/masterThesis/doc/ressources/blockchain_block.png}
\caption{Global structure of a blockchain}
\label{}
\end{figure}
\newline
With this structure, blockchains are inherently resistant to modification of the data: Once recorded, the data in a block cannot be altered retroactively. Moreover, since it is working in a decentralized way, each node (e.g computer connected to the network) has and need to have a copy of all transactions. Therefore, it is easy to verify a transaction easily with this record since they are public.

\subsubsection{Transactions}
\paragraph{}
A transaction is the record of transfering money from a person A to a person B, following these two easy but essential rules: 
\begin{itemize}
  \setlength\itemsep{0em}

  \item It is only possible to transfer coins that we owned, using transaction \emph{Pay}
  \item It is only miners that can create bitcoin, using a transaction \emph{Coinbase}
\end{itemize}
\paragraph{}
\emph{Coinbase} and \emph{Pay} transactions are described in the following figure X.X. Bob is a miner, so he is allowed to create bitcoins. This creation of bitcoin is actually "Coinbase" transaction, signed by the private key (Kpriv) of Bob, to ensure its authenticity. Once Bob has this bitcoin to his possession, he can pay Alice one bitcoin, by creating a "Pay" transaction: First, Bob needs to point Alice's public key (Kpub) or wallet, reference the previous "Coinbase" transaction by its hash, and finnally sign this transaction by Bob's private key. Alice can now transfer this bitcoin to Eve, by excecuting the same "Pay" transaction steps. 
\begin{figure}[!h]
\centering
\includegraphics[scale=0.40]{/home/emmanuel/Documents/masterThesis/doc/ressources/simple_transaction.png}
\caption{1-coin transaction}
\label{}
\end{figure}

\paragraph{}
Then, these transactions are speaded to all nodes to the network, via the gossip protocol[*]. Each node has a copy of all transactions that are currently happening in the network. Moreover, the referencing of the previous transaction, allows any user to trace one bitcoin from its creation to his current position in a wallet.
\paragraph{}
However, a number of issues relevant to the functioning of transactions can be noticed: spending more than one bitcoin per transactions, spending non-round figure of bitcoin and the case of the double spent.
\paragraph{}
As mentioned earlier in this section, it is only possible to spend one bitcoin. The figure X.X shows that it is possible to reference multiple transacations in a \emph{Pay} transactions.
\begin{figure}[htp]
\centering
\includegraphics[scale=0.40]{/home/emmanuel/Documents/masterThesis/doc/ressources/transaction_2coins.png}
\caption{2-coin transaction}
\label{}
\end{figure} 
After mining, Bob creates two \emph{CoinBase} transactions to himself, transfering two bitcoins to his wallet. In order to send two bitcoin to Alice, Bob points to its two previous \emph{Coinbase} transactions and sign this transaction.
\paragraph{}
The second problem - spending non-round figure of bitcoin - can be handled as shown in figure X.X. Let's assume Alice has received 2 bitcoins from Bob, and she now wants to spend 1.5 bitcoin to Eve, and 0.5 bitcon to
Robert.
\newline
Alice need to create first the 1.5 bitcoin out of the 2 bitcoins she received from Bob. 
\begin{figure}[htp]
\centering
\includegraphics[scale=0.40]{/home/emmanuel/Documents/masterThesis/doc/ressources/transaction_1,5coins.png}
\caption{1,5-coin transaction}
\label{}
\end{figure}
She creates a \emph{Pay} transaction with two recipients: Eve with an amount of 1.5 bitcoin and herself with the rest of the 2 bitcoins, here 0.5 bitcoin. She points to the 2-bitcoin transaction hash between her and Bob, signs this transaction and now can transfer 1.5 bitcoin to Eve. Alice should follow this procedure, because in Bitcoin, a transaction recipient must be consumed entirely. That is the reason why Alice is paying back 0.5 bitcoin for herself. Finnally, she can also send this 0.5 bitcoin to Robert.
\paragraph{}
The third and last problem is called the double-spent transaction.
\begin{figure}[htp]
\centering
\includegraphics[scale=0.40]{/home/emmanuel/Documents/masterThesis/doc/ressources/double_spent_transaction.png}
\caption{Double-spent transaction}
\label{}
\end{figure}
\paragraph{}
The double expense consists of issuing two transactions in the same time that spend the same credit: the first transaction is issued to pay a first recipient Eve, the second transaction is issued to pay an accomplice Robert or the hacker himself, in order to recover the amount spent. In order for the fraud not to be immediately discovered, these two transactions must coexist in two competing instances of the blockchain. The second instance must become the longest blockchain (See X.X.X.X block section) for the fraud to succeed. In this case, the first transaction can not be recycled into another block because it will be considered invalid because it is incompatible with the second transaction and will ultimately be rejected. If, between the two transactions, the first recipient has accepted the payment, he will not find out afterwards that this transaction has been rejected. Since the participants are anonymous, they can not turn against the fraudster.

\paragraph{}
This scenario is possible due to the dissemination of a transaction. Each transaction needs to be transfered to all nodes. If the blockchain was a complete instataneous system, and transactions were sent instantly, the double-spent problem can be solved by taking only the transaction which comes first (to Eve), and state the second transaction (to Robert) invalid. Unfortunately, Internet network has some latency, and maybe a node located in Australia received the transaction intended to Robert first. The central key point of Bitcoin is to find a concensus without any central entity, and without trusting every node, because some people may be malicious. One concensus per transactions would create tremendous amount of work. Hence the creation of blocks.   

\subsubsection{Block}
\paragraph{}
The simplified internal structure of a block is composed of a \emph{Prev\_ Hash}, \emph{TimeStamp}, \emph{Tx\_Root\_Hash} and \emph{Nonce}. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.39]{/home/emmanuel/Documents/masterThesis/doc/ressources/block.png}
\caption{Internal structure of one block}
\label{}
\end{figure}

\begin{itemize}
  \setlength\itemsep{0em}

  \item \emph{Prev\_ Hash}: The reference to the previous block stored as a SHA-256 hash. This creates the backlink
  \item \emph{TimeStamp}: It indicates when the block is created (Unix time)
  \item \emph{Tx\_Root\_Hash}: It is the merkle tree root hash of all transactions currently stored in this block (SHA-256)
  \item \emph{Nonce}: It is a 4-byte hash which is an answer to a difficult-to-solve mathematical puzzle (equation).This answer is unique to each block (see Nonce section) 

\end{itemize}

\textbf{More details???????????}
\newline
By agreeing on a block, all miners agree on the flow of transactions, and which ones are correct or not.
\newline
- Fork
\newline
- How can be the the transaction is valid
\newline
- transaction every 10 mins
\newline
-how much transaction per block
\subsubsection{Miners, Proof of Work \&  Nonce}

- pseudo code of what are all the steps to confirm one block
- proof of work
\subsubsection{Nounce}
- complexity varies
\newline
- calculation of hashes
\newline 
- random hash
\newline
- pseudo code how to resolve a hash
\newline
- example of a nounce
\subsubsection{Fork}
\subsubsection{Payment}
- Evolution of the difficulty
\newline
- problem of pool mining
\subsection{Ethereum: the 2.0 blockchain}
\subsubsection{What is Ethereum?}
- blockchain 2.0
\newline
- blockchain that can store 
\newline
- faster blockchain but engender new problems
\newline
- really expensive to store data
\newline
- everything is public
\subsubsection{Blocks}
\subsubsection{GHOST}
- orphan blocks
- godfather blocks
- scheme
\subsubsection{Transaction}
\subsubsection{Accounts}
 - ID
 \newline
 - balance
 \newline
 - storage root
 \newline
 - code hash
 \newline
 - one account per user / smart contract
 \newline
 - storage : non accessible outside account
 \newline
 \begin{figure}[htp]
\centering
\includegraphics[scale=1.00]{/home/emmanuel/Documents/masterThesis/doc/ressources/blockchain_summary.png}
\caption{Blockchain secure workflow}
\label{}
\end{figure}
 1 	Digitally signed transaction initiation
2 	Transaction is sent to miner who verifies transaction
3 	Transaction is broadcast to all connected nodes as block
4 	Network accepts transaction if data is valid
5 	Receiver receives the transaction
  \subsubsection{Smart Contracts}
- stored in blockchain
\newline
- can modify the state of the blokchain
\newline
- associted to one unique account
\newline
- conditions/ loops / unlimited stacks \& memory/
\newline
- example of transaction with ethereum
\newline
- smart contract call talk to other smart contracts  
\newline
- properties 
- constrainsts
\newline
- solidity, serpent, LLL
\newline
- Dapps
\subsubsection{Oracle}
- smart contracts that can provide pieces of information of the external world
\newline
- synchrone mode
\newline
- asynchrone mode
\newline
\textbf{WHY DO WE DO THIS ?}

\subsubsection{differences with bitcoin}
blockchain state machine with transaction which modify the state
\subsection{Decentralized Storage Providers}

\subsubsection{IPFS}

\subsubsection{StorJ}

\subsubsection{Dat-data}

\subsubsection{Swarm}

\subsubsection{Overall Requirements Examination}

\subsection{Access control????}

